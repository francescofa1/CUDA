# -*- coding: utf-8 -*-
"""cuda exp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14gonzCHskkmVZQQnkXPPnIRXMeAqGCXL
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile cuda_code.cu
# 
# 
# #include <iostream>
# #include <vector>
# #include <thrust/host_vector.h>
# #include <thrust/device_vector.h>
# #include <thrust/functional.h>
# #include <thrust/transform_reduce.h>
# #include <random>
# #include <chrono>
# 
# // RGB structure to represent a pixel
# struct Pixel {
#     unsigned char r, g, b;
# };
# 
# 
# // Function to generate a random pixel
# Pixel getRandomPixel() {
#     std::random_device rd;
#     std::mt19937 gen(rd());
#     std::uniform_int_distribution<int> distribution(0, 255);
# 
#     Pixel pixel;
#     pixel.r = distribution(gen);
#     pixel.g = distribution(gen);
#     pixel.b = distribution(gen);
# 
#     return pixel;
# }
# 
# // Define a predicate to check if a pixel is purple
# struct IsPurplePixel : public thrust::unary_function<Pixel, int> {
#     __host__ __device__
#     int operator()(const Pixel& pixel) const {
#         // You may need to adjust these values based on your definition of purple
#         return (pixel.r > 150 && pixel.g < 50 && pixel.b > 150) ? 1 : 0;
#     }
# };
# 
# int main() {
#     // Define image dimensions
#     int numRows = 1000;
#     int numCols = 1000;
# 
#     // Create a matrix of random pixels
#     std::vector<std::vector<Pixel>> randomMatrix(numRows, std::vector<Pixel>(numCols));
#     for (int i = 0; i < numRows; ++i) {
#         for (int j = 0; j < numCols; ++j) {
#             randomMatrix[i][j] = getRandomPixel();
#         }
#     }
# 
#     // Copy the random matrix to a device vector
#     thrust::device_vector<Pixel> deviceImage;
#     for (const auto& row : randomMatrix) {
#         deviceImage.insert(deviceImage.end(), row.begin(), row.end());
#     }
# 
#     // Measure the time for counting purple pixels without thrust
#     auto startWithoutThrust = std::chrono::high_resolution_clock::now();
# 
#     int purplePixelCountWithoutThrust = 0;
#     for (const auto& row : randomMatrix) {
#         for (const auto& pixel : row) {
#             if ((pixel.r > 150) && (pixel.g < 50) && (pixel.b > 150)) {
#                 purplePixelCountWithoutThrust++;
#             }
#         }
#     }
# 
#     auto endWithoutThrust = std::chrono::high_resolution_clock::now();
#     auto durationWithoutThrust = std::chrono::duration_cast<std::chrono::microseconds>(endWithoutThrust - startWithoutThrust);
# 
#     // Measure the time for counting purple pixels with thrust
#     auto startWithThrust = std::chrono::high_resolution_clock::now();
# 
#     int purplePixelCountWithThrust = thrust::transform_reduce(
#         deviceImage.begin(),
#         deviceImage.end(),
#         IsPurplePixel(),
#         0,
#         thrust::plus<int>()
#     );
# 
#     auto endWithThrust = std::chrono::high_resolution_clock::now();
#     auto durationWithThrust = std::chrono::duration_cast<std::chrono::microseconds>(endWithThrust - startWithThrust);
# 
#     // Print the random matrix
#     /*
#     std::cout << "Random Matrix:\n";
#     for (const auto& row : randomMatrix) {
#         for (const auto& pixel : row) {
#             std::cout << "(" << static_cast<int>(pixel.r) << ", " << static_cast<int>(pixel.g) << ", " << static_cast<int>(pixel.b) << ") ";
#         }
#         std::cout << "\n";
#     }
#     */
# 
#     // Print the number of purple pixels without thrust and the time taken
#     std::cout << "Time taken without parallel programming algorithms: " << durationWithoutThrust.count() << " microseconds" << std::endl;
#     std::cout << "(Count of purple pixels: " << purplePixelCountWithoutThrust << ")" << std::endl;
# 
#     // Print the number of purple pixels with thrust and the time taken
#     std::cout << "Time taken using parallel programming algorithms: " << durationWithThrust.count() << " microseconds" << std::endl;
#     std::cout << "(Count of purple pixels: " << purplePixelCountWithThrust << ")" << std::endl;
# 
# 
#     return 0;
# }
#

!nvcc cuda_code.cu -o cuda_code
!./cuda_code